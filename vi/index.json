[{"content":"Kernel Debugger Setup Mình dùng VirtualBox để debug kernel, VmWare chắc cũng làm được tương tự\nVào Machine Settings -\u0026gt; Ports -\u0026gt; Serial -\u0026gt; Enable Serial Port\nPort Number: Tuỳ :)))\nPort mode: Host Pipe\nConnect to existing : Bỏ tick\nPath/Address: /tmp/vbox\nBoot Linux lên bình thường, Lấy root dùng\necho ttyS0,9600 \u0026gt; /sys/module/kgdboc/parameters/kgdboc\nnếu Port Number là COM1 -\u0026gt; ttyS0, COM2 -\u0026gt; ttyS1, vv\nSang máy host, chạy\nsocat -d -d /tmp/vbox pty \u0026amp;\nSocat sẽ chay background, output ra cái tty là debugger port.\nLấy /boot/vmlinuz , extract bằng extract-vmlinux có trên linux source tree\ngdb vmlinuz (gdb) target remote /dev/ttyXXX //Cái mà socat output Enjoy\nNOTES:  Chỉ có thể attach gdb khi vào lúc nó chuẩn bị panic :\u0026lt;  P/s: Hình như cũng có thể attach từ đầu = boot flag kgdboc ttyS0,9600 kgdbwait thì phải?\nReference Somewhere in the internet :\u0026lt; Sorry\n","description":"","id":0,"section":"post","tags":["debug","kernel","linux"],"title":"Debug Linux Kernel trong VM","uri":"https://trungnguyen1909.github.io/blog/vi/post/misc/KDB/KDB/"},{"content":"KSMASH Background Đây là 1 bài exploit linux kernel module của nyaacate@gmail.com host ở vòng 3 MatesCTF 2018-2019\nBài này mình solve sau giờ :\u0026lt; nhưng vì trước khi kết thúc CTF khoảng 2hr mà chưa mình chưa thấy team nào solved bài này cả,\nnên là mình vẫn mạnh dạn gửi exploit code vào mail tác giả.\nExploit\nChallenge Description Có một kernel module đang chạy, nhiệm vụ là từ non-root user escape lên r00t để đọc file /root/flag\nReversing Kernel module có tên là kmod, bạn có thể tìm thấy file executable bằng lệnh\n$ modinfo kmod filename: /lib/modules/4.18.0-15-generic/kernel/drivers/char/kmod.ko author: nyaacate license: Unlicense srcversion: 764EF51CE35A221A02D9CA0 depends: retpoline: Y name: kmod vermagic: 4.18.0-15-generic SMP mod_unload mở IDA64, load kmod.ko lên, sẽ tìm thấy những điều sau\n  Kernel module giao tiếp bằng file /proc/havoc\n  Khi đọc từ đó, kernel module sẽ ngây thơ đọc kernel memory cho chúng ta bằng hàm careless_read\n  Khi viết vào đó, kernel module sẽ ngây thơ viết nguyên si vào kernel memory cho chúng ta bằng hàm careless_write\n  Có thể thấy, 2 hàm đều đọc và viết và 1 kí tự :)\n  Đây là 1 bài Buffer Overflow kernel cơ bản :)\n  Protection :   kASLR (kernel level Address Space Layout Randomization) : chắc là quen thuộc rồi nhỉ :) nhưng là ở kernel thôi :)\n  SMEP (Supervisor Mode Execution Protection) : Cơ chế bảo vệ ở CPU, không cho phép đọc instruction từ user memory :)\n  Kernel Stack Cookies (Canary)\n  Exploit Vector : Từ kernel, gọi commit_creds(prepare_kernel_cred(0)) để lên r00t rồi trở về userspace.\n  Đầu tiên, chúng ta đọc kernel memory từ /proc/havoc để lấy thông tin\n  Thông tin quan trọng sẽ nằm ở offset 1\n  \t--------------------------- | Stack Canary | --------------------------- | Saved RBX | --------------------------- | Saved RBP | --------------------------- | Saved RIP | ---------------------------   Như vậy, chúng ta có thể Leak và Defeat Stack Canary\n  Kernel ASLR defeated bằng cách tính offset từ RIP\n  Công việc còn lại là ROP để lên r00t và quay về\n  Trong kernel không có gadget mov rdi, rax để chuyển kết quả của prepare_kernel_cred cho commit_creds,\ntuy nhiên, vì 1 lý do nào đó, RAX lúc đó lại sẵn = RDI nên chúng ta không cần :) (dùng kernel Debugger sẽ hiểu :))\n  Cuối cùng là SWAPGS xong rồi IRETQ (interrupt return) để trở về chương trình của chúng ta từ kernel\n  IRETQ sẽ khôi phục lại một số register như là RIP, CS, RFLAGS, RSP, SS, cụ thể, nó sẽ pop từ stack như sau\n  Notes \u0026amp; Issue  Chúng ta không thể để fake stack ở vị trí đầu memory page vì như vậy sẽ gây stack overflow trong kernel,  Ta cần chọn address như là 0x60fffe00 chẳng hạn ( nói chung là đừng nhiều số 0 quá là được :))\n Khi mình IRETQ về, mình bị SIGSEGV ở mọi câu lệnh mà RIP trỏ vào :\u0026lt; (IDKY),  Thế nên mình đã làm 1 trò dirty bẩn bựa là handle signal SIGSEGV bằng 1 hàm, trong đó, mình để system(\u0026quot;/bin/sh\u0026quot;) :))\n  Tất cả thông tin về cách giao tiếp \u0026amp; những thứ khác vv thì các bạn có thể check file exploit.c\n  KP trên các máy \u0026gt;= 4th Gen(Haswell) do SMAP -\u0026gt; bypassable = ROP cr4\n  Solution ret2usr sẽ không qua được vì từ Linux 4.15, kernel sẽ map tất tần tần userspace memory thành NX.\n  SIGSEGV khi iretq cũng là do KPTI(Kernel Page Table Isolation) (a.k.a KAISER) có từ khi patch Meltdown\n=\u0026gt; Resolve bằng cách ROP CR3?\n  Gotchas :)  Trong /home/nyan có source của kernel module :)))  Reference ROP your way to Kernel part 1\nROP your way to Kernel part 2\nPractical SMEP bypass techniques on Linux\nCả 3 đều là của tác giả Vitaly Nikolenko :O\nChanges in Linux Kernel\n","description":"","id":1,"section":"post","tags":["matesCTF","CTF","pwn","kernel","linux"],"title":"matesCTF KSMASH","uri":"https://trungnguyen1909.github.io/blog/vi/post/matesctf/KSMASH/"},{"content":"Notebook Exploit\nBài này mình pwn được sau khi được tiền bối Đào Xuân Nghĩa thông não sau giờ.\nĐây là 1 bài Heap overflow.\nchecksec:\n[*] '/root/matesctf/notebook' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Có 2 loại note (bình thường: 1000bytes. Lớn: 2000bytes)\nCác notes được lưu ở dạng double linked-list. 16 bytes đầu của mỗi note sẽ lưu note tiếp theo(FD) và note trước (BK)\nGoal Overwrite FD và BK để nó trỏ về GOT của _IO_getc. Sau đó dùng chức năng Edit để ghi vị trí của canyourunme vào\nBug Lỗi logic nghiêm trong ở phần Edit.\nĐối với note bé, ta sẽ có (1000-16)=984 bytes cho dữ liệu, tuy nhiên, ta lại được EDIT những 992 bytes.\n=\u0026gt; Tức là đã tràn 8 bytes để có thể edit cái size của note tiếp theo\nExploit Như vậy là ta có thể áp dụng kĩ thuật overlapping chunks\nMình sẽ edit size của 1 note thành tổng của nó và cái tiếp theo rồi free.\nNhư vậy, ptmalloc2 sẽ bị lừa rằng là nó sẽ có 1 khoảng trống gấp đôi ở đó và sẽ allocate Big note vào đó.\nTrên thực tế, cái note sau vẫn được chương trình coi như bình thường\n=\u0026gt; Ta sẽ tạo 1 cái Big note ở đó rồi đè lên FD và BK bằng vị trí của GOT _IO_getc - 16\nKhi đi qua cái note đó, thì dù Back hay Next đều khiến cho chương trình coi GOT là 1 cái note và tức là ta có thể edit tuỳ ý.\nEdit nó bằng vị trí của canyourunme là ta có shell.\nNhư thường lệ, cat flag sẽ cho chúng ta flag.\nReference Đào Trọng Nghĩa\nhow2heap\n","description":"","id":2,"section":"post","tags":["matesCTF","CTF","pwn","heap"],"title":"matesCTF notebook","uri":"https://trungnguyen1909.github.io/blog/vi/post/matesctf/notebook/"}]