<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RITSEC on Nguyen Hoang Trung</title>
    <link>https://trungnguyen1909.github.io/blog/tags/RITSEC/</link>
    <description>Recent content in RITSEC on Nguyen Hoang Trung</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 22 Nov 2018 21:30:28 +0700</lastBuildDate>
    
	<atom:link href="https://trungnguyen1909.github.io/blog/tags/RITSEC/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>RITSEC18 Bucket-o-cash</title>
      <link>https://trungnguyen1909.github.io/blog/post/RITSEC-2018/Bucket-o-cash/</link>
      <pubDate>Thu, 22 Nov 2018 21:30:28 +0700</pubDate>
      
      <guid>https://trungnguyen1909.github.io/blog/post/RITSEC-2018/Bucket-o-cash/</guid>
      <description>By cating and grepping the file, we know that there was a file named /home/memes/flag.c
It&amp;rsquo;s probably a program, so I searched for ./flag Just printing the line doesn&amp;rsquo;t seem to work so I tried
 cat memorydump | grep -A 10 -B 10 ./flag I found an interesting base64-encoded string that is repeated multiple times.
Decode it, the flag is yours.
Also, later I realised that a great pattern to grep for challs like this are the base64-encoded of the beginning part of the flag format, which is constant.</description>
    </item>
    
    <item>
      <title>RITSEC18 Freeze</title>
      <link>https://trungnguyen1909.github.io/blog/post/RITSEC-2018/Freeze/</link>
      <pubDate>Thu, 22 Nov 2018 21:30:28 +0700</pubDate>
      
      <guid>https://trungnguyen1909.github.io/blog/post/RITSEC-2018/Freeze/</guid>
      <description>It&amp;rsquo;s clearly a python compiled program since there is a libpython and also, when using decompiler, there was a function name PyDontWriteByteCode
using &amp;lsquo;pyi-archive-viewer&amp;rsquo; we can extract the main function.
Append headers to the file
 &amp;quot;\x03\xf3\x0d\x0a\xf1\x32\x75\x5a&amp;quot; using uncompyle, we can get the main function.
Change the key a little bit Â±k*360 and we will get the flag.</description>
    </item>
    
    <item>
      <title>RITSEC18 Gimme sum fud</title>
      <link>https://trungnguyen1909.github.io/blog/post/RITSEC-2018/Gimme-sum-fud/</link>
      <pubDate>Thu, 22 Nov 2018 21:30:28 +0700</pubDate>
      
      <guid>https://trungnguyen1909.github.io/blog/post/RITSEC-2018/Gimme-sum-fud/</guid>
      <description>The binary loads the flag.txt to the memory and asks us to provide input.
Interesting things is that it loads to the same memory segment with the input.
Debugging locally, I found it at the offset 752 from the first input bytes.
Running it multiple times on the server and at sometimes, the null bytes will be all-cleared and puts will print it all.</description>
    </item>
    
    <item>
      <title>RITSEC18 The tangled web</title>
      <link>https://trungnguyen1909.github.io/blog/post/RITSEC-2018/The-tangled-web/</link>
      <pubDate>Thu, 22 Nov 2018 21:30:28 +0700</pubDate>
      
      <guid>https://trungnguyen1909.github.io/blog/post/RITSEC-2018/The-tangled-web/</guid>
      <description>wget -r fun.ritsec.club:8007
You may find the file Fl4gggg1337.html is referenced or has already been download. The flag wasn&amp;rsquo;t there, but it has link to Stars.html.
Fetch that file, the base64 encoded string is the flag for this challenge.</description>
    </item>
    
    <item>
      <title>RITSEC18 Yet another HR Management Framework</title>
      <link>https://trungnguyen1909.github.io/blog/post/RITSEC-2018/Yet-another-HR-Management-Framework/</link>
      <pubDate>Thu, 22 Nov 2018 21:30:28 +0700</pubDate>
      
      <guid>https://trungnguyen1909.github.io/blog/post/RITSEC-2018/Yet-another-HR-Management-Framework/</guid>
      <description>By judging the program&amp;rsquo;s interface, we know that it was a heap challenge.
Spent quite a lot of time reversing it, I figured it out that it malloc a few bytes for the person struct on the heap, then the name will be malloc with the size entered and that address will be put in the person struct.
The person struct also has a function pointer which is set to the printPerson function.</description>
    </item>
    
  </channel>
</rss>