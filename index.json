[{"content":"Teleport  Please write a full-chain exploit for Chrome. The flag is at /home/user/flag. Maybe there\u0026rsquo;s some way to tele\u0026lt;port\u0026gt; it out of there?\n 1. Story Hi, last week I participated in Google CTF 2020 with my team pwnPHOfun\nAlthough I didn\u0026rsquo;t solve the challenge in time for the points,\nstill, here is a writeup for the challenge teleport for you.\nI like to write detailed articles that are understandable and replicable to my past self. Feel free to skip any parts. Here is a table of content for you.\n Teleport  1. Story 2. Overview  2.1. Sandboxed or unsandboxed 2.2. Provided primitives   3. Leaking the browser process 4. Googling 5. Leaking the renderer process 6. Nodes and Ports 7. Leaking ports\u0026rsquo; names  7.1. Finding offsets  7.1.1. Simple structures 7.1.2. F**k C++/Traversing std::unordered_map     8. What do we do with stolen ports?  8.1. Factory of network requests 8.2. Making the leaked ports ours  8.2.1. Calling functions from shellcode   8.3. Sending our messages 8.4. Writing our messages 8.5. To know who our receivers are 8.6. Where are my factory ??  8.6.1. Setting the sequence_num 8.6.2. Getting the correct function parameters     9. Closing words  9.1. Shoutout 9.2. Reference      You may want to checkout the exploit code.\nNo IDA/Ghidra were used during the creation of this work. I used only GDB.\n2. Overview The challenge files include a patch for chromium version 84.0.4147.94,\nwhich basically has 2 features.\nThe first one is the Pwn object, and a code execution(?) primitive Mojo::rce\nBoth could be trivially used through MojoJS, which is enabled for us.\n2.1. Sandboxed or unsandboxed On the first sight, the challenge seems unexpectedly easy, or wasn\u0026rsquo;t it ;)\nBut the rce primitive only provides us code execution inside the renderer process, which is strictly sandboxed.\nThe Pwn object is on the unsandboxed browser process, provides an address leak of itself and an arbitrary memory read primitive.\n2.2. Provided primitives So we have 2 primitives\n Sandboxed code execution inside renderer process Arbitrary read inside browser process  3. Leaking the browser process The primitive Pwn::this() will return the address of itself, which is a C++ object.\nAs every C++ object have its vtable, containing pointers to all instance methods, located at offset 0x0. By dereference the pointer returned by Pwn::this() twice, you will get a function pointer. Subtracting it to a constant offset, you can find the _text base of the browser\u0026rsquo;s process.\n4. Googling Because no obvious way to get code execution inside the browser\u0026rsquo;s process, I started looking around on the internet and found this article,\nWhich is, by itself, interesting:\n  First the article is written by @_tsuro or Stephen Roettger, and you can find his name in chall.patch\n  Second, these words in the article is also interesting:\n \u0026hellip; used from a compromised renderer\n  \u0026hellip; if you have an info leak vulnerability in the browser process\n   Isn\u0026rsquo;t that was our case ;)\nLater, my teammate found this speech, also given by Stephen\nWasn\u0026rsquo;t that a smart way to make people read your article and watch your talk? ;)\nAnyway, I highly recommend you watch those to get a basic overview of the solution or even solve it yourself.\n5. Leaking the renderer process With the rce primitive in our hands, the sky is your limit\u0026hellip;\nFirst, we want a pointer in our renderer process to be able to reuse Chrome\u0026rsquo;s code.\nTake a look at the Mojo::rce function\n1 2 3 4 5 6 7 8 9 10  void Mojo::rce(DOMArrayBuffer* shellcode) { size_t sz = shellcode-\u0026gt;ByteLengthAsSizeT(); sz += 4096; sz \u0026amp;= ~(4096llu-1); void *mm = mmap(0, sz, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0); ... memcpy(mm, shellcode-\u0026gt;Data(), shellcode-\u0026gt;ByteLengthAsSizeT()); void (*fn)(void) = (void (*)(void)) mm; fn(); }   So the function copy our code into a newly-allocated Read-Write-Executable(rwx) page, and then execute it, right?\n1 2 3 4  0x0000000009088315 \u0026lt;+277\u0026gt;:\tmov rdi,rbx ; dest  0x0000000009088318 \u0026lt;+280\u0026gt;:\tmov rsi,r15 ; source  0x000000000908831b \u0026lt;+283\u0026gt;:\tcall 0xa00f7e0 \u0026lt;memcpy@plt\u0026gt; 0x0000000009088320 \u0026lt;+288\u0026gt;:\tcall rbx   The above was the assembly equivalent for 3 last lines of code. There are 2 things worth mentioned:\n rbx and rdi will store the address of the rwx page r15 will store the address of our original buffer  This enables us to RETURN an arbitrary number of values from the shellcode by writing to [r15+X],\nthen read it back in JavaScript.\nFor me, I read the return pointer from [rsp] to get a function pointer,\nand derive the renderer\u0026rsquo;s _text base.\n6. Nodes and Ports Node could be understood as process; when you launch chrome, it will spawn multiple children to isolate their data in case of compromisation, and each of them is a node.\nNode\u0026rsquo;s name is a 128-bit random integer\nA node has multiple local ports listening for messages; each of them has an attached endpoint which will consume the messages.\nSimilar to node, port\u0026rsquo;s name is also a 128-bit random integer\nA port is addressed using its node\u0026rsquo;s name and its name (node:port)\nKnowing a port\u0026rsquo;s name and its node\u0026rsquo;s name is equivalent to being able to send messages to that port.\n ‚Äú[\u0026hellip;] any Node can send any Message to any Port of any other Node so long as it has knowledge of the Port and Node names. [\u0026hellip;] It is therefore important not to leak Port names into Nodes that shouldn\u0026rsquo;t be granted the corresponding Capability.‚Äù\nSecurity section of Mojo core\n A node knows its own name\n1 2 3 4 5  class COMPONENT_EXPORT(MOJO_CORE_PORTS) Node { ... const NodeName name_; ... }   A port knows its name and its node\u0026rsquo;s name\n1 2 3 4 5 6 7  class Port : public base::RefCountedThreadSafe\u0026lt;Port\u0026gt; { // The Node and Port address to which events should be routed FROM this Port.  // Note that this is NOT necessarily the address of the Port currently sending  // events TO this Port.  NodeName peer_node_name; PortName peer_port_name; }   7. Leaking ports\u0026rsquo; names A node keeps track of its name, its local ports, and its remote ports (ports from another nodes that is known to this node)\n1 2 3 4 5 6 7  class COMPONENT_EXPORT(MOJO_CORE_PORTS) Node { ... const NodeName name_; ... std::unordered_map\u0026lt;LocalPortName, scoped_refptr\u0026lt;Port\u0026gt;\u0026gt; ports_; ... }   By reading the browser process\u0026rsquo;s memory and traverse through ports_, it\u0026rsquo;s possible to steal a privileged port.\nOne possible pointer path is g_core-\u0026gt;node_controller_-\u0026gt;node_\nJust traverse that and dump all the ports\u0026rsquo; names.\n7.1. Finding offsets 7.1.1. Simple structures Finding offsets isn\u0026rsquo;t a trivial task when you haven\u0026rsquo;t familiar with assembly and memory, but a way to do that is to disassemble functions where that field is accessed.\nIf you are experienced in finding offsets, it is okay to skip this part.\nFor example, to find the offset of node_controller_ in g_core, you could try disassemble this function\n1 2 3 4 5 6  NodeController* Core::GetNodeController() { base::AutoLock lock(node_controller_lock_); if (!node_controller_) node_controller_.reset(new NodeController(this)); return node_controller_.get(); }   this pointer is always passed as the first argument\n1  0x0000000003723fba \u0026lt;+10\u0026gt;:\tmov r15,rdi   and this time, it is stored in r15 register\nThe following code should be equivalent to the if(!node_controller_)\n1 2  0x0000000003723fc9 \u0026lt;+25\u0026gt;: mov rbx,QWORD PTR [r15+0x30] 0x0000000003723fcd \u0026lt;+29\u0026gt;: test rbx,rbx   Or the below should be equivalent to the return statement\n1 2 3 4 5  0x0000000003723ffd \u0026lt;+77\u0026gt;: mov rbx,QWORD PTR [r15+0x30] 0x0000000003724001 \u0026lt;+81\u0026gt;: mov rdi,r14 0x0000000003724004 \u0026lt;+84\u0026gt;: call 0xa00fad0 0x0000000003724009 \u0026lt;+89\u0026gt;: mov rax,rbx ; return value  0x000000000372400c \u0026lt;+92\u0026gt;: add rsp,0x8   So the offset is probably +0x30.\nThe way of finding the remaining offsets is left as an exercise to the readers.\n7.1.2. F**k C++/Traversing std::unordered_map Okay, now how do we dump all ports?\nThe worst thing about C++ containers is that their methods are inlined\nOne of our candidates for disassembling this time is\n1 2 3 4 5 6 7 8 9 10  int Node::GetPort(const PortName\u0026amp; port_name, PortRef* port_ref) { PortLocker::AssertNoPortsLockedOnCurrentThread(); base::AutoLock lock(ports_lock_); auto iter = ports_.find(port_name); if (iter == ports_.end()) return ERROR_PORT_UNKNOWN; ... *port_ref = PortRef(port_name, iter-\u0026gt;second); return OK; }   because it used the .find method\nDisassembling it will give you a loooong and complicated(?) function, but there are a few interesting points\n1 2 3 4  0x0000000006d6c443 \u0026lt;+51\u0026gt;:\tmov rdi,QWORD PTR [r14+0x50] 0x0000000006d6c447 \u0026lt;+55\u0026gt;:\tmov r12d,0xfffffff6 0x0000000006d6c44d \u0026lt;+61\u0026gt;:\ttest rdi,rdi 0x0000000006d6c450 \u0026lt;+64\u0026gt;:\tje 0x6d6c5d2 ; not found   There\u0026rsquo;s a nullcheck here, which is equivalent to this one. So 0x50 is probably where bucket_count() is\nContinuing the path through a bunch of calculation with constants:\n1 2 3  0x0000000006d6c4f4 \u0026lt;+228\u0026gt;: mov rax,QWORD PTR [r14+0x48] 0x0000000006d6c4f8 \u0026lt;+232\u0026gt;: mov rax,QWORD PTR [rax+r8*8] 0x0000000006d6c4fc \u0026lt;+236\u0026gt;: test rax,rax   The second statement of the above code is what we want.\n[rax+r8*8] is an array access, with rax holding the base address, r8 is probably the array index and 8 is surely the element size.\nAnd it\u0026rsquo;s definitely this line\n1  __next_pointer __nd = __bucket_list_[__chash];   So __bucket_list_ is probably at offset +0x48\nAn std::unordered_map works by calculate the __constrain_hash() of the key and put the element(key-value) in the equivalent bucket.\nEach bucket is implemented as a linked list.\nAt this point, it is reasonable for anyone to try to iterate all non-null elements(bucket) to dump all the elements by traversing the linked list.\nHowever, this turns out to be a bad way to do so and I could even find duplicate elements and bad pointers.\nHowever, with a bit of more time, you will find this defintion\n1 2 3 4  __bucket_list __bucket_list_; pair\u0026lt;__first_node, __node_allocator\u0026gt; __p1_; pair\u0026lt;size_type, hasher\u0026gt; __p2_; pair\u0026lt;float, key_equal\u0026gt; __p3_;   So __p1_.first will be our first element (.begin()).\nWith the .begin() pointer, it is possible to iterate through all elements just like a linked list. Inspecting the memory, you will find that +0x10 from the __bucket_list_ (+0x58) is a good educated guess for the .begin() pointer.\nReference\n8. What do we do with stolen ports? 8.1. Factory of network requests One of the good candidates for a good target is a privileged URLLoaderFactory, which relies in the network service, and has the ability to make network requests (URLLoaderFactory::CreateLoaderAndStart), with files\nURLLoaderFactories are wrapped by CorsURLLoaderFactories, which enforced CORS to all requests.\nTo isolate origins, factories created with renderers cannot be used to make requests to another origins.\nHowever, the browser can create factories (process_id_==kBrowserProcess) allowing arbitrary network requests with no CORS enforced to be made.\nIf we could get such factory from the browser, we could upload any files to our server.\n However, I noticed a code path that allows you to create a large amount of privileged URLLoaderFactories using service workers. If you create a service worker with navigation preload enabled, every top-level navigation would create such a loader. By simply creating a number of iframes and stalling the requests on the server side, you can keep a few thousand loaders alive at the same time.\n@_tsuro\n To do so is pretty trivial, just make sure to use HTTPS and you are good to go with the service worker.\n8.2. Making the leaked ports ours To send messages to the leaked ports\u0026rsquo; names, we need to register it to our node. Below is my way of doing it:\n Create a new port on our node using Node::CreateUninitializedPort Initialize it with our leaked names using Node::InitializePort  After doing that, the leaked port will be inserted into your node\u0026rsquo;s ports_ map.\n8.2.1. Calling functions from shellcode It is impractical to run an assembler in the exploit to compile your shellcode with the functions\u0026rsquo; addresses, as they shift around all the time under ASLR.\nThere are probably many ways of doing this, including ways that allow you to call functions directly from JavaScript.\nHowever, I will stick to the assembly this time and use the Mojo::rce primitive.\nIn my shellcode, there will be a common pattern, which looks like this\n1 2  mov rax, 0x4141414141414141 call rax   The 0x4141414141414141 value will be encoded as it as 8 consecutive little-endian bytes in the machine code. The JavaScript code will be responsible to replace it with the correct address calculated from the leak.\n8.3. Sending our messages In the Core object, there are some interesting APIs\n Core::CreateMessage Core::AppendMessageData Core::SendMessage  The purposes of them are clear just by their names.\nHowever, the Core::SendMessage API takes a MojoHandle message_pipe_handle (an uint32_t) as a parameter, which is the receiving port.\nTo get a MojoHandle, we can use the API\nMojoHandle CreatePartialMessagePipe(const ports::PortRef\u0026amp; port),\nwhich creates handles for our newly-created ports.\nLater, I found the function mojo::WriteMessageRaw, which takes our port\u0026rsquo;s MojoHandle, message buffer, and an array of MojoHandles(?) and send the message.\nUnfortunately, it takes a C++ object MessagePipeHandle, which is not so easy to create. So all I can do was replicate its function calls.\n8.4. Writing our messages If you take a look at the binding JS code (i.e. URLLoaderFactoryProxy.prototype.createLoaderAndStart), you will see that it uses the JavaScript API MessageV0Builder to craft a message. That function will return a Message object, which contains a buffer, and an array of handles.\nOur message obviously should contain the buffer, but what are the handles?\nThe function URLLoaderFactory::CreateLoaderAndStart has 2 special parameters: mojo::PendingReceiver\u0026lt;mojom::URLLoader\u0026gt; receiver and mojo::PendingRemote\u0026lt;mojom::URLLoaderClient\u0026gt; client. PendingReceiver and PendingRemote indicate that these are shared objects, which are accessed through ports.\nTo pass these objects as parameters, you need to pass their handles, just 2 uint32_t to Core::AppendMessageData.\nIf you inspect the message generated by MessageV0Builder, its array of handles will contain 2 elements, equivalent to receiver and client. These elements are strings: URLLoaderInterfaceRequest, and URLLoaderClientPtr, respectively.\nSo we need to pass 2 handles, an InterfaceRequest and an Ptr. But how do we figure them out?\nHere is the code to create a URLLoaderClient\n1 2 3 4 5 6  var client = new network.mojom.URLLoaderClientPtr(); Mojo.bindInterface( network.mojom.URLLoaderClient.name, mojo.makeRequest(client).handle, \u0026#34;process\u0026#34; );   This parameter mojo.makeRequest(client).handle also seems like a handle. Its implementation can be viewed here.\n1 2 3 4 5 6 7 8 9  template \u0026lt;typename Interface\u0026gt; InterfaceRequest\u0026lt;Interface\u0026gt; MakeRequest( InterfacePtr\u0026lt;Interface\u0026gt;* ptr, scoped_refptr\u0026lt;base::SequencedTaskRunner\u0026gt; runner = nullptr) { MessagePipe pipe; ptr-\u0026gt;Bind(InterfacePtrInfo\u0026lt;Interface\u0026gt;(std::move(pipe.handle0), 0u), std::move(runner)); return InterfaceRequest\u0026lt;Interface\u0026gt;(std::move(pipe.handle1)); }   It seems to create a MessagePipe, which will create 2 MojoHandles: handle0 and handle1.\n handle0 is binded to the passed Ptr handle1 is binded to a newly created InterfaceRequest  Lucky to us, handles are generated increasingly. So we can predict the handles of the Ptr and InterfaceRequest from the handle of our port.\n8.5. To know who our receivers are While creating this exploit, I ran into a programming bug which prevents my message buffer being copied. This leads me to discover a way to know which object is behind the port:\nBy sending an invalid message (set the first uint32_t (num_bytes) to 0), you can trigger a validation error at this line and the verbose logging will print something like this\nMojo error in NetworkService:Validation failed for network.mojom.CookieAccessObserver [master] MessageHeaderValidator [VALIDATION_ERROR_UNEXPECTED_STRUCT_HEADER] That\u0026rsquo;s it, now you know who are you sending to.\n8.6. Where are my factory ?? I stucked and cannot find any factories within the leaked ports. There are even some ports which never responds to any of my messages.\nAt this point (ofc after the CTF has ended), Stephen points out my missing bit: I didn\u0026rsquo;t set the messages\u0026rsquo; sequence_num. It seems like the Mojo system use this number to prevent message duplication.\nThis number is increased by one when a message is sent. Fortunately, the correct sequence_num is stored in the Port object in the field next_sequence_num_to_send, which can be leaked from where we found our ports in browser process\u0026rsquo;s memory.\n8.6.1. Setting the sequence_num Let me remind you that MojoMessageHandle is actually a pointer to a UserMessageEvent. Unfortunately, the function set_sequence_num is inlined so the offset isn\u0026rsquo;t free. However, you could get it by disassembling Node::PrepareToForwardUserMessage\n8.6.2. Getting the correct function parameters This is a trivial part. Just take a look at the JavaScript Mojo binding code.\n9. Closing words The devil is actually in the details, isn\u0026rsquo;t it ;)\n9.1. Shoutout  To Stephen, for creating this challenge, and pointing out my missing bit (after the CTF, ofc). Thank you a lot.  9.2. Reference  Stephen\u0026rsquo;s article on P0 blog Stephen\u0026rsquo;s talk at OffensiveCon20  ","description":"","id":0,"section":"post","tags":["GGCTF2020","CTF","pwn","sandbox","chromium","browser","mojo","reversing","offset"],"title":"Google CTF 2020 teleport: Chromium sandbox escape","uri":"https://trungnguyen1909.github.io/blog/post/GGCTF20/"},{"content":"PlaidStore Story Hi, everyone, this is the writeup for the challenge 500pts \u0026ldquo;mojo\u0026rdquo; of PlaidCTF 2020.\nAs usual, I got the flag after the CTF has ended :\u0026lt;\nWell, currently I am not in any active teams, so I decided to pick a hard challenge and do it on my own.\nYou may want to checkout the exploit code\nChallenge Description Chromium commit detached at 81.0.4044.92 (commit hash 82e68b9038ab5679543b300b42202bc053c50930). Our task is to RCE chromium browser, after applying this diff\nWe are also provided generated mojo-js files to interact with the IPC.\n+++ b/third_party/blink/public/mojom/plaidstore/plaidstore.mojom @@ -0,0 +1,11 @@ +module blink.mojom; + +// This interface provides a data store +interface PlaidStore { + + // Stores data in the data store + StoreData(string key, array\u0026lt;uint8\u0026gt; data); + + // Gets data from the data store + GetData(string key, uint32 count) =\u0026gt; (array\u0026lt;uint8\u0026gt; data); +}; We now have access to the new interface through MojoJS.\nPath of Exploitation Creating connection Urghhh, I stuck on this part for more than a day just to find the way to interact with the interface.\nLots of google-fu, renderer bad messages, promise rejection :\u0026lt;\nBut it\u0026rsquo;s actually really easy :\u0026lt;. Just add those lines to your html\n1 2  \u0026lt;script src=\u0026#34;mojo/public/js/mojo_bindings_lite.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;third_party/blink/public/mojom/plaidstore/plaidstore.mojom-lite.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   and in an async function of your Javascript, use this line to get a handle of the object, owned by the current frame, and interact.\n1 2 3  let p = blink.mojom.PlaidStore.getRemote(true); await p.storeData(\u0026#34;yeet\u0026#34;,new Uint8Array(0x28).fill(0x41)); (await p.getData(\u0026#34;yeet\u0026#34;, count).data;   smh.\nThe first bug Well, the first bug I noticed was this one\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  void PlaidStoreImpl::GetData( const std::string \u0026amp;key, uint32_t count, GetDataCallback callback) { if (!render_frame_host_-\u0026gt;IsRenderFrameLive()) { std::move(callback).Run({}); return; } auto it = data_store_.find(key); if (it == data_store_.end()) { std::move(callback).Run({}); return; } std::vector\u0026lt;uint8_t\u0026gt; result(it-\u0026gt;second.begin(), it-\u0026gt;second.begin() + count); std::move(callback).Run(result); }   Can you spot the most obvious bug?\nThe count parameter has no checks on it.\nAs a result, the result array is being intialized with out-of-bound memory if count is larger than it-\u0026gt;second.size()\nSo we got a heap out-of-bound read here.\nTo leak useful pointers from the heap, I put 0x40 arrays of (0x28 bytes) to the PlaidStore,\nwhile attempting to allocate PlaidStore object right after each allocation.\nMost of the time, the PlaidStore objects will lie after those arrays, which means we can read their pointers.\nThe most interesting one is their C++ vtable pointer, it points to the DATA section of the binary and contains pointers to instance methods.\nSo we could read that pointer, subtract it from the offset and find the base of the binary in memory.\nPlaidStoreImpl objects will have the vtable pointer at offset 0 (always) and to its render_frame_host_ at offset 8 (C++ classes are like structs).\nBecause a few high bits of the vtable address is always the same, and same goes to the highest byte, we could find them easily in the leak.\ncontent::PlaidStoreImpl::PlaidStoreImpl is the constructor of the object so it will set the vtable\nchrome[0x3c584a8] \u0026lt;+24\u0026gt;: call 0x57044b0 ; operator new(unsigned long) chrome[0x3c584ad] \u0026lt;+29\u0026gt;: lea rcx, [rip + 0x635e2ec] ; vtable for content::PlaidStoreImpl + 16 chrome[0x3c584b4] \u0026lt;+36\u0026gt;: mov qword ptr [rax], rcx \u0026gt;\u0026gt;\u0026gt; hex(0x3c584b4+0x635e2ec) '0x9fb67a0' -\u0026gt; the pointer(unslided) will be stored at offset 0 Or (lldb) image lookup -r -v -s \u0026quot;vtable for content::PlaidStoreImpl\u0026quot; will do the trick.\nKeep it mind that the stored address will be off +16 bytes from the symbol\nAnyway, so we should find the pointer that looks like 0x5x..7a0\nAnd the pointer lie next to that will be its render_frame_host_\nGet code execution\u0026hellip; At the starts of all methods of PlaidStore, there\u0026rsquo;s a check (!render_frame_host_-\u0026gt;IsRenderFrameLive()) seems to check whether its frame is live.\nBut it doesn\u0026rsquo;t take into account that its render_frame_host_ is valid or not.\nIf the PlaidStore's frame has been freed, its render_frame_host_ will be dangling and the memory it is pointing to is subjected to reallocation.\nSo there\u0026rsquo;s definitely an use-after-free bug here.\nTo exploit that, we could create an iframe in the document.body and get its PlaidStore pointer, which will have its render_frame_host_ pointed to the iframe.\nWe can easily access the iframe's properties, as long as its source is in the same origin.\nAfter get the PlaidStore pointer from there, we could deallocate the iframe by remove it from the document.body.\nThe best way to reallocate it back is to creating some allocations of the same size, for example 1024 allocations.\nBy doing that, we are creating pressure to the memory and most of the time, the frame will ended up being garbage-collected and let us allocate to the same memory.\nAlso, you can\u0026rsquo;t rely on the fact that that memory is returned to allocation immediately, and by allocating numerous of times, it will increase the chance of successful reallocation.\nThe RenderFrameHost object\u0026rsquo;s size is 0xc28, which could be found by the method below:\n  content::RenderFrameHostImpl::RenderFrameHostImpl() is called after that C++ object is allocated (a.k.a. constructor)\n  Searching in the chromium source, it\u0026rsquo;s called from content::RenderFrameHostFactory::Create(), looking into that function\u0026hellip;\n  Just before the constructor is called, the object\u0026rsquo;s allocated using operator new(unsigned long size)\n  So we can figure out the size using a new called that comes before the constructor is called.\n  1 2  mov edi, 0xc28; \tcall operator new(); =\u0026gt; size = 0xc28   So now we have a handle to a fake RenderFrameHost object that its content is controlled by us.\nWith that primitive, we could fake its vtable, and now render_frame_host_-\u0026gt;IsRenderFrameLive()'s now ours.\n//content::PlaidStoreImpl::StoreData chrome[0x3c581da] \u0026lt;+26\u0026gt;: mov rdi, qword ptr [rdi + 0x8] //rdi = this-\u0026gt;render_frame_host_ chrome[0x3c581de] \u0026lt;+30\u0026gt;: mov rax, qword ptr [rdi]//rax = vtable chrome[0x3c581e1] \u0026lt;+33\u0026gt;: call qword ptr [rax + 0x160]//call vtable-\u0026gt;IsRenderFrameLive So the pointer at offset 0x160 of the fake object\u0026rsquo;s vtable is called (fake-\u0026gt;vtable[0x160]()), we could put the address of our first gadget in the ROP chain there.\nI put a xchg rax, rsp first to change the stack pointer to point to our controlled data.\nFrom here, we do a classic ROP chain to execvp@plt to read the flag.\n Use ROPgadget to find gadgets in the binary. ropper analysis took me forever.\n Further details about the ROP chain could be found in pwn.js\nExploit Most of the parts are contained in pwn.js.\nThe HTMLs parts are zipped in exploit.zip.\nPut them inside the extracted directory of mojo_js.zip\nThe Flag The flag is\n PCTF{PlaidStore_more_like_BadStore}\n But it didn\u0026rsquo;t bring me any 500pts :\u0026lt;\nThanks~\n  The challenge author for making me get into chromium for the first time.\n  You, for reading till here.\n  ","description":"","id":1,"section":"post","tags":["PlaidCTF2020","CTF","pwn","chromium","browser","mojo","use-after-free","UAF"],"title":"PlaidCTF2020 PlaidStore mojo chromium","uri":"https://trungnguyen1909.github.io/blog/post/PlaidCTF2020/"},{"content":"CrackIT Writeup for CrackIt task at Google CodeIn 2019\n1stcrackme easy, you can use strings 1stcrackme to list all strings in binary\nstripped output:\nEnter password: FEDORAGCIPASSEASY Success! Error! Wrong password! Because the password should be around the prompt and the so we could try FEDORAGCIPASSEASY because it looks like a password\n(my intuition, please don\u0026rsquo;t ask)\nAnd it works\n[user@archlinux Crackit-GCI]$ ./1stcrackme Enter password: FEDORAGCIPASSEASY Success! Enter password: When I enter the string again, It didn\u0026rsquo;t work. At this point I look the strings output again and then I saw 2 more suspicious strings\n0x1337 0x133337 Yeah, Who doesn\u0026rsquo;t want to be l33t ;)\nSo I opened it in Ghidra to checkout the whole logic.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  undefined8 main(void) { int iVar1; char local_78 [112]; printf(\u0026#34;Enter password: \u0026#34;); __isoc99_scanf(\u0026amp;DAT_00102015,local_78); iVar1 = strcmp(local_78,\u0026#34;FEDORAGCIPASSEASY\u0026#34;); if (iVar1 == 0) { puts(\u0026#34;Success!\\r\u0026#34;); } else { puts(\u0026#34;Error! Wrong password!\\r\u0026#34;); } printf(\u0026#34;Enter password: \u0026#34;); __isoc99_scanf(\u0026amp;DAT_00102015,local_78); iVar1 = strcmp(local_78,\u0026#34;0x1337\u0026#34;); if (iVar1 == 0) { puts(\u0026#34;Success!\\r\u0026#34;); } else { puts(\u0026#34;Error! Wrong password!\\r\u0026#34;); } printf(\u0026#34;Enter password: \u0026#34;); __isoc99_scanf(\u0026amp;DAT_00102015,local_78); iVar1 = strcmp(local_78,\u0026#34;0x133337\u0026#34;); if (iVar1 == 0) { puts(\u0026#34;Success!\\r\u0026#34;); } else { puts(\u0026#34;Error! Wrong password!\\r\u0026#34;); } return 0; }   Look at the s2 parameter of strcmp call that compares our input with that hardcoded password,\nwe solved all 3 password challenges of this program.\n[user@archlinux Crackit-GCI]$ ./1stcrackme Enter password: FEDORAGCIPASSEASY Success! Enter password: 0x1337 Success! Enter password: 0x133337 Success! 2ndcrackme [user@archlinux Crackit-GCI]$ ./2ndcrackme usage: ./2ndcrackme \u0026lt;password\u0026gt; okok, so the binary requires us to put the password on the CLI paramter. I put a random string there.\n[user@archlinux Crackit-GCI]$ ./2ndcrackme a Error! Wrong Password! The strings command output doesn\u0026rsquo;t show any suspicious strings like before, so I use ltrace\nHere is the output\n[user@archlinux Crackit-GCI]$ ltrace ./2ndcrackme a strcmp(\u0026quot;a\u0026quot;, \u0026quot;FEd0raGCIt@sk\u0026quot;) = 27 puts(\u0026quot;Error! Wrong Password!\u0026quot;Error! Wrong Password! ) = 23 +++ exited (status 0) +++ We can see that the program does strcmp our supplied password with another string\nthat seems to be hardcoded in a way that it doesn\u0026rsquo;t show up in strings\n[user@archlinux Crackit-GCI]$ ./2ndcrackme FEd0raGCIt@sk Success! Solved\n3rdcrackme Okay, I open the binary in GHIDRA\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  undefined8 main(void) { int iVar1; char local_48 [32]; undefined8 local_28; undefined8 local_20; undefined4 local_18; undefined2 local_14; int local_c; local_28 = 0x306b403136673030; local_20 = 0x313531646e616c30; local_18 = 0x6c656334; local_14 = 0x21; local_c = 0; printf(\u0026#34;Enter the password! \u0026#34;); gets(local_48); iVar1 = memcmp(local_48,\u0026amp;local_28,0x16); if (iVar1 == 0) { local_c = 1; } puts(\u0026#34;\\nChecking password...\\n\u0026#34;); if (local_c != 0) { puts(\u0026#34;Successfully logged in!\\nGood job!\u0026#34;); /* WARNING: Subroutine does not return */ exit(0); } puts(\u0026#34;Login failed!\u0026#34;); return 0; }   So it gets our password from stdin and then memcmp with a pointer(\u0026amp;local_28) and the size is 0x16\nThere\u0026rsquo;re 5 integers which is intialized with 5 hexadecimal integers\nBy intuition, I immediately realized that those hexs are actually ASCII character.\nBecause Ghidra doesn\u0026rsquo;t know the types of those variable, It splits them into 5 integers.\nThe integers are named after their locations on the stack (offset from stack base).\nAlso, because characters are represented in memory just like integers, it\u0026rsquo;s just the way we understand it matters.\nKnowning that, we convert those integers to characters.\nDon\u0026rsquo;t forget our architecture is Little endian so we have to reverse the byte order\u0026hellip;\nAnyway, I checkout the assembly code of that pseudo code.\n\t001011af 48 b8 30 MOV RAX,\u0026quot;00g61@k0\u0026quot; 30 67 36 31 40 6b 30 001011b9 48 ba 30 MOV RDX,\u0026quot;0land151\u0026quot; 6c 61 6e 64 31 35 31 001011c3 48 89 45 e0 MOV qword ptr [RBP + local_28],RAX 001011c7 48 89 55 e8 MOV qword ptr [RBP + local_20],RDX 001011cb c7 45 f0 MOV dword ptr [RBP + local_18],\u0026quot;4cel\u0026quot; 34 63 65 6c 001011d2 66 c7 45 MOV word ptr [RBP + local_14],'!' f4 21 00 and let Ghidra do the conversation for me.\nSo in the program memory, It should be 00g61@k00land1514cel!,\nwhich is local_28+local_20+local_18+local_14+local_c\n(plus is understood as string concatenation)\nThe memcmp get the pointer to the first character in the\nKnowing the value that our password is going to be compare with, we solved the problem.\n[user@archlinux Crackit-GCI]$ ./3rdcrackme Enter the password! 00g61@k00land1514cel! Checking password... Successfully logged in! Good job! .\n.\n.\nWait, there\u0026rsquo;s more.\nThe program used gets to read a string to the stack without size limitations.\nThis exposes the program to a buffer-over-flow vulnerbility.\nWe can overwrite those variables, including the correct password.\nHere is a better pseudo code to look at.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  int __cdecl main(int argc, const char **argv, const char **envp) { char input[32]; // [rsp+0h] [rbp-40h] \tchar password[28]; // [rsp+20h] [rbp-20h]  int v6; // [rbp-8h] \tstrcpy(password, \u0026#34;00g61@k00land1514cel!\u0026#34;); v6 = 0; printf(\u0026#34;Enter the password! \u0026#34;, argv); gets(input); if ( !memcmp(input, password, 0x16uLL) ) v6 = 1; puts(\u0026#34;\\nChecking password...\\n\u0026#34;); if ( *(_DWORD *)\u0026amp;password[28] ) { puts(\u0026#34;Successfully logged in!\\nGood job!\u0026#34;); exit(0); } puts(\u0026#34;Login failed!\u0026#34;); return 0; }   At here, you can see the intialized correct password.\nBy the way, strcpy might have been optimized so you won\u0026rsquo;t see it in the binary.\nThe input is located on top of the password. Which means that on the right of the input is the intialized password\nMemory:\nLow-------------------\u0026gt;High |input(32bytes)|password(28 bytes)|v6(4 bytes)|sp(8 bytes)|ip(8 bytes)| So we can overwrite the password and make the input identical with the password.\n[user@archlinux Crackit-GCI]$ ./3rdcrackme Enter the password! AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Checking password... Successfully logged in! Good job! .\n.\n.\nNot so fast, Until I checkout the function list, I found a function named secret which seems to be our real destination.\nThe buffer-over-flow vulnerbility here is so powerful that it can drive us into any functions.\nP/s: The memory representation up there still applied here.\nIP = Instruction Pointer. It is saved there so we can return to our previous function. But if we overwrite it, we can go anywhere we want!\nP/s 2: For the next part, I\u0026rsquo;m gonna disable Linux\u0026rsquo;s ASLR:\nRun this command from root shell.\n# echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space So if we overwrite ip with secret's address, we can get there.\nsecret is at 0x555555555175, we convert that address to bytes then put it at the ip, which is at 66 bytes from the start of our input.\nOh, by the way, If exit(0) is called, ip won\u0026rsquo;t be used as exit use a short-circuit path to exit the program.\nSo you will need the password to be incorrect to reach there.\nBecause the comparison result(v6) is also saved on the stack,\nwe need to overwrite it with 4 zero bytes (because it is an integer) to force it to be zero.\nIf you overwrite it with non-zero bytes, it will exit(0) and we can\u0026rsquo;t get secret running.\nHere is the command to prepare the input and pipe it in to the program.\n$ python -c \u0026quot;print('\\x41'*0x20+'\\x42'*0x1c+'\\x00'*4+'\\xde\\xad\\xbe\\xef'+'\\x75\\x51\\x55\\x55\\x55\\x55')\u0026quot; \\ | ./3rdcrackme Enter the password! Checking password... Login failed! You found the secret function! Congrats! The password is: FEDORAPASSWORDGCI! Thanks for reading!\n","description":"","id":2,"section":"post","tags":["GCI","CodeIn","Google","easy","reverse"],"title":"CrackIt, GCI","uri":"https://trungnguyen1909.github.io/blog/post/GCI/CrackIt/"},{"content":"pwning your kernelz Background Hi everyone,\nThis is the writeup for the challenge pwning your kernelz, created by Linus Henze(@LinusHenze),\nI came across this challenge when Linus tweeted a status update for the CTF.\nOf course, I didn\u0026rsquo;t solve this challenge during the time of the CTF. In fact, no one does.\nSo I decided to pick it up and exploit it with the support of Linus after the CTF ends.\nYou may want to checkout the exploit code\nUpdate: the bug has been assigned as CVE-2019-8781 by Apple and fixed in the macOS Catalina 10.15 release.\nChallenge description Original description\nThe challenge required us to perform a Local Privilege Escalation to r00t user to get the flag.\nSMEP is on,\nSMAP is off,\nkASLR slide is provided,\nand the kernel is the latest development macOS kernel from Apple\u0026rsquo;s KDK.\nActually, at the time of the CTF,\nApple messed up and unpatched the 121 day (CVE-2019-8605) and you can just port the iOS exploit code to macOS and here we go.\nBut I didn\u0026rsquo;t think of that during the time of the CTF, also I was pretty busy at that time so I didn\u0026rsquo;t think about it.\nBut later, I decided to pick up the intended bug.\nPOC So the author provided us the following POC:\n1 2 3 4  x86_saved_state32_t state; memset(\u0026amp;state, 0xFF, sizeof(x86_saved_state32_t)); thread_set_state(mach_thread_self(), x86_SAVED_STATE32, (thread_state_t) \u0026amp;state, x86_SAVED_STATE32_COUNT); while (1) {}   You will need to compile it to a 32bit program -m32 to make it works.\nThe POC is such a simple one that it immediately hang the whole machine.\nDebugging I wasted a lot of time to setup the VM and trying to debug with Apple\u0026rsquo;s kdp, but with this bug, triage it with kdp is hard.\nThe machine just hang because it\u0026rsquo;s constantly doublefault.\nLater, when I knew about the VMWare\u0026rsquo;s gdb debugging stub, it actually makes my life much easier\nCheck it out here\nTriaging the bug The challenge mentioned about the need of 32bit apps, so we knows that the bug is somewhere in the /osfmk/kern/i386/\nThe cross-arch code starts to differ from the machine_thread_set_state call.\nSo I found 2 snippets of code that share the same purpose but have different logic.\nInside the switch flavor case of the x86 version of machine_thread_set_state, you can find 2 different version\nIf the flavor is x86_SAVED_STATE32, the machine just hang.\nIf the flavor is x86_THREAD_STATE32, it does not cause any problem.\nBut they are supposed to have the similar behavior, so lets diff them out.\nAlthough going through the same amount of checks, the second version forced the segment registers to be a value that\u0026rsquo;s constantly defined\nIn the buggy one, we can see that it allows a wider range of segment registers\u0026rsquo; value, which could be malicious.\nSo, the bug is that we can set the segment registers\u0026rsquo; values to any malicious values.\nThis is similar to the BadIRET bug\nConsequences Attaching the debugger, tracing down through the iretq instruction, it failed to return due to invalid segment registers and jump to the fault handler,\nFollowing the execution, we can observe that the fault handler does MISS a swapgs instruction.\nSo why does this is troublesome?\nThe swapgs instruction changes the current GS base of the running code from kernelspace to userspace and vice versa.\nSome data are accessed relatively through the GS register so we control some of the kernel\u0026rsquo;s data.\nIn case you don\u0026rsquo;t know what the segment registers are, they are just the index of some entries in the GDT (Global Descriptor Table).\nEach entries contains meaningful data, one of them are the base address. And we can access data relatively from that base address through the registers\nExploit Following the buggy path, we can see that it repeatedly jump to the fault handler and always fault at the same instruction\n1  cmp dword ptr gs:0x174, 0   in the ks_dispatch_kernel function.\nIt fault because it accesses data through the GS base, which is currently pointing to the user\u0026rsquo;s GS base and access to the unmapped memory.\nThe reason is that it\u0026rsquo;s using the userspace\u0026rsquo;s GS base has the base address at 0x0.\nTo get over, we need to remove the _PAGEZERO segment by a linker switch, and allocate memory there with vm_allocate call.\nContinuing with our zero-filled memory we just allocated, the kernel panic in kernel_trap with the error type is 13 (general protection (#GP))\nAccording to the Intel\u0026rsquo;s SDM, iretq with invalid segment registers can cause a #GP fault\nSo how can we get over that that?\nA piece of code that we did not consider yet is the specific handler for #GP fault:\n1 2 3 4 5  if (thread != THREAD_NULL \u0026amp;\u0026amp; thread-\u0026gt;recover) { set_recovery_ip(saved_state, thread-\u0026gt;recover); thread-\u0026gt;recover = 0; return; }   This might seems rather unintersting,\nbut if you disassemble it and resolve the macro,\nwe can see that we controlled the thread-\u0026gt;recover value because it\u0026rsquo;s accessed that through the GS base, which we controlled.\nThe set_recovery_ip set the location of the handler code in the next time the fault is occured, then we are dismissed from the fault handler.\nSo, by the next time we iretq fails, we have control over the kernel\u0026rsquo;s RIP.\nNext, I observed that we have some registers that we control over the thread_set_state call. One of them is the $RBP register.\nSo, I find a leave; ret; gadget (which should be plenty in the kernel code base) to pivot the kernel\u0026rsquo;s stack to a userspace address.\nThere, we set up our ROP chain to escalate ourselves.\nYou can find the typical privilege escalation ROP chain here\nBut there\u0026rsquo;s still something to note.\nFirst, we need to bear in mind that the GS base is still in the userspace upon the start of the ROP chain,\nwhich causes some fault in the current_proc function as it used the GS base, so we need to fix that.\nSecond, thread_exception_return will NOT work as the saved_state is invalid and messed up.\nBecause there aren\u0026rsquo;t any swapgs gadgets, we need to make ourselves at the userspace and return there.\nBefore we can do that, we need to ROP to turn off SMEP by unset the 20th(0-indexed) bit of the $cr4 register.\nTo return to the userspace, we need to set up ourselves the iretq stack, which looks like this\n |--------------------------| | Low mem addr | ^ |--------------------------| | | RIP | | \u0026lt;-- current RSP |--------------------------| | | CS | | |--------------------------| | | EFLAGS | | |--------------------------| | | RSP | | |--------------------------| | | SS | | |--------------------------| | | High mem addr | | |--------------------------| | then swapgs and iretq should do the trick.\nUpon coming back, I encountered the misaligned_stack_error_ when going through the dyld stub.\nI workaround this by catching that SIGSEGV error: signal(SIGSEGV,aftermath);\nEnding words During exploitation of this bug, I stuck lots of time and need to be pointed out.\nI found lots of flaws in my reverse engineering and code reading skills and missed some of important points.\nBut at least, I make time for myself to reading through the kernel code.\nAlso, this\u0026rsquo;s the first time I exploit a kernel 0 day that hasn\u0026rsquo;t been disclosed and exploited publicly yet.\nI enjoy this challenge.\nShoutouts   Apple for the 0day.\n  Linus Henze(@LinusHenze). He created a challenge in which I learnt a lot.\nAlso, he helped me a lot in exploitation by pointing out the points that I have missed. Thank you very much.\n  ","description":"","id":3,"section":"post","tags":["Camp-CTF","pwn","kernel","xnu","0day"],"title":"pwning your kernelz: macOS 0day LPE","uri":"https://trungnguyen1909.github.io/blog/post/CampCTF/PwningKernelz/"},{"content":"kpets  welcome to Kernel Pets Simulator!\n  We wrote a pet store application that was too slow, so we made a kernel module for it instead.\n  Author: pippinthedog\n Hi everyone, this is the writeup for the Facebook CTF 2019 Qualification Round kpets challenge\nYou may want to checkout the exploit code\nDescription We are given a linux kernel module, packed with a qemu VM that runs Linux 5.1.5.\nThe module, like it\u0026rsquo;s self-introduction, is a application that can create and view pets.\nWe\u0026rsquo;ll communicate with the module by reading and writing over the pseudo-file-descriptor /dev/kpets\ndev_read is the read handler, while dev_write is the write handler.\nThe only path that leads us to the flag is in the dev_read method, when the value 0xAA is in the first byte of a pet.\nThe other path will print the pets and then return;\nWe should try to make a pet that have a 0xAA in the first byte.\ndev_write will create a new pet from the struct that we written in.\nIt\u0026rsquo;s perform some sanity checks to prevent buffer-overflow.\nMost importantly, it checks that the first byte shouldn\u0026rsquo;t be 0xAA\nOne more thing, by reversing (which I haven\u0026rsquo;t found during the CTF üò≠), we can see that it saves the pets backward.\nBug 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  int dev_write(__int64 a1, char *buf, __int64 sz) { v17 = sz; copy_from_user(\u0026amp;v19, buf + 4, 4LL); if ( v19 \u0026gt; 0x20 ) { printk(\u0026#34;kpets: invalid pet name len: 0x%02x\\n\u0026#34;, v19); return v17; } copy_from_user(\u0026amp;v20, buf + 40, 4LL); if ( v20 \u0026gt; 0x40 ) { printk(\u0026#34;kpets: invalid pet description len: 0x%02x\\n\u0026#34;, v20); return v17; } //Cut off \tprintk(\u0026#34;kpets: your new pet owner is %s!\u0026#34;, names[v21 % 6]); copy_from_user(\u0026amp;v18, buf, 1LL); if ( (unsigned __int8)(v18 + 64) \u0026gt; 1u \u0026amp;\u0026amp; v18 != 0xC2u ) { printk(\u0026#34;kpets: invalid pet type: 0x%02hhx\\n\u0026#34;, v18); } else { copy_from_user(\u0026amp;v21, buf + 4, 4LL); *v10 = v18; copy_from_user(v10 + 8, buf + 8, (unsigned int)v21); copy_from_user(v10 + 44, buf + 44, v20); } return v17; }   We can see that it checks the supplied length of the pet\u0026rsquo;s name and the supplied length of the pet\u0026rsquo;s description\nand then copy that amount of data to kernel memory.\nThe problem is in this piece of code:\n1 2 3 4 5 6 7 8 9 10  copy_from_user(\u0026amp;v19, buf + 4, 4LL); if ( v19 \u0026gt; 0x20 ) { printk(\u0026#34;kpets: invalid pet name len: 0x%02x\\n\u0026#34;, v19); return v17; } ... copy_from_user(\u0026amp;v21, buf + 4, 4LL); *v10 = v18; copy_from_user(v10 + 8, buf + 8, (unsigned int)v21);   The module copies the length from the userspace, perform checks on it, and copies it AGAIN from the userspace, unchecked, to use it as the copy length.\nBy doing this, it introduces a race condition.\nThat value may have been changed in the user\u0026rsquo;s memory between two copies, which invalidates the sanity checks.\nFrom here, we have a buffer-overflow with arbitrary data\u0026rsquo;s length on the name field of the kernel memory.\nTo exploit this, we can create a new thread that repeatedly changes the length value in the userspace.\nThe remaining road to the flag\u0026hellip;. Well, I did stop here 8 hours before the CTF ends\u0026hellip;.\nIt was a late Sunday night\u0026hellip;\nMy teammates are resting for the next Monday\u0026hellip;\nI was stuck.\nWell, after 2 weeks, I\u0026rsquo;m here.\nTo finish what I did start\u0026hellip;.\nBut then I continued to fail.\nI decided to read some spoilers\u0026hellip;.\nBack on.\nWe can see that it saves the pets backward.\nSo, we can just first create a pets that satisfies all the condition.\nThen use the race condition to make the next pet\u0026rsquo;s name overflows to the previous one with 0xAA\nThen, we got the flag.\nShoutout   pippinthedog from Facebook CTF for bringing a great challenge for me.\n  WALLY0813\u0026rsquo;s writeup. Without that writeup, I couldn\u0026rsquo;t have finish the leftover part.\n  ","description":"","id":4,"section":"post","tags":["FBCTF","CTF","pwn","kernel","linux","race-condition","double-fetch"],"title":"kpets FacebookCTF 2019 QR","uri":"https://trungnguyen1909.github.io/blog/post/FBCTF19-Qual/kpets/"},{"content":"IPwnKit  Come and take a bite of the Apple!\n  We have reserved you a very special place at the WWPC (World Wide Pwning Conference).\n  Email ipwnkit@gmail.com to RSVP and we will reply with your invite.\n  Come, test your skills, and win pwn2ooown!!!\n  Fine print: sw_vers 17E202.\n  The VM will be reset between exploit attempts.\n  If you panic the kernel and don\u0026rsquo;t walk away with the flag, you are BANNED FROM THIS CHALLENGE, so make it count!\n  Please don\u0026rsquo;t waste our time.\n  The flag is in /var/root/flag.\n Hi everyone, this is the writeup for the DEFCON 26 Qualification Round\u0026rsquo;s iPwnKit challenge\nYou may want to checkout the exploit code\nPrerequisites  IOKit basic communication. You can read chapter 5 of the book OS X and iOS Kernel Programming.  Description The author gives us a macOS IOKit kernel extension and a kernel binary, and our job is to get root and read that file without panic the kernel.\nThere are many functions in the kernel extension, but we only need to care about the functions which are in the io_oooverflow_IPwnKitUserClient class.\nWhen we invoke through the IOConnectCall method family, our passing arguments will be packed as the second parameter of the externalMethod function\nFrom there, the kernel extension will check through the dispatch table and invoke our selector function.\nOur vtable has the symbol IPwnKitUserClient::sMethods which is basically an array of IOExternalMethodDispatch\n1 2 3 4 5 6 7 8  struct IOExternalMethodDispatch { IOExternalMethodAction function; uint32_t checkScalarInputCount; uint32_t checkStructureInputSize; uint32_t checkScalarOutputCount; uint32_t checkStructureOutputSize; };   The data in this struct will be used to check the input/output size before it jumps to our selected function\nWhen a check does not need to be enforced, the value kIOUCVariableStructureSize (-1) will be there.\nAccording to the dispatch table in the kernel extension, it will dispatch to the methods that are prefixed with \u0026rsquo;s\u0026rsquo; before the actual function.\nObviously, the interesting methods are ReadNum, WriteNum, and FillArray\nBut before we can get there, we have to go through sReadNum, sWriteNum, and sFillArray, correspondingly.\nI will not cover reverse-engineer stuff because after I finished my first exploit, I\u0026rsquo;d realized that I did lots of obsolete stuff due to errors in reverse engineer, and I will mostly show the source code instead.\n Reversing C++ is hard =(\n But basically, the UserClient class has an array as property and we are supposed to use those functions to manipulate it.\nHere is an over-simplified declaration of the struct IOExternalMethodArguments which is used to pass the method\u0026rsquo;s arguments\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  struct IOExternalMethodArguments { ... const uint64_t * scalarInput;//24-8 \tuint32_t scalarInputCount;//32-4  const void * structureInput;//36-8 \tuint32_t structureInputSize;//44-4  IOMemoryDescriptor * structureInputDescriptor;//48-8  uint64_t * scalarOutput;//56-8 \tuint32_t scalarOutputCount;//64-4  void * structureOutput;//68-8 \tuint32_t structureOutputSize;//76-4  IOMemoryDescriptor * structureOutputDescriptor;//8 \tuint32_t structureOutputDescriptorSize;//4 \t... };   The sReadNum has an error called \u0026ldquo;no descriptor\u0026rdquo; and also, the input structure size limit is unlimited, which means that we need to make use the IOMemoryDescriptor * structureInputDescriptor field.\nThis field is used to pass structure that is larger than the page size (4096 bytes).\nWhen the structure argument is smaller than the page size, it will be copied over the kernel memory.\nBut when it\u0026rsquo;s larger than the page size, IOKit will use that field to create a reference to the userland memory.\nIn other words, it\u0026rsquo;s called out-of-line transmission.\nBug It\u0026rsquo;s boring to write inside the array though, so we may want an out-of-bounds read and write.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  IOReturn IPwnKitUserClient::sReadNum(IPwnKitUserClient* target, void* reference, IOExternalMethodArguments* arguments) { ... int64_t idx; arguments-\u0026gt;structureInputDescriptor-\u0026gt;readBytes(0, \u0026amp;idx, sizeof (idx)); if (idx \u0026gt;= sizeof (IPwnKitUserClient::myNumbers) || idx \u0026lt; 0) { IOLog(\u0026#34;invalid index %d\\n\u0026#34;, idx); return KERN_FAILURE; } return target-\u0026gt;ReadNum(arguments); } IOReturn IPwnKitUserClient::ReadNum(IOExternalMethodArguments *arguments) { IOLog(\u0026#34;%s[%p]::%s reading number stored\\n\u0026#34;, getName(), this, __FUNCTION__); read_num_t rnum; arguments-\u0026gt;structureInputDescriptor-\u0026gt;readBytes(0, \u0026amp;rnum, sizeof (read_num_t)); int64_t idx = rnum.index; arguments-\u0026gt;scalarOutput[0] = idx; arguments-\u0026gt;scalarOutput[1] = this-\u0026gt;myNumbers[idx]; return KERN_SUCCESS; }   We can see that the method sReadNum read the structure from the Descriptor and then perform both the lower and upper bound checks for the index and invoke the ReadNum method\nDid you spot the bug here?\nThe structureInputDescriptor is a reference to the userland memory. It does perform the check on the value but not always the one will be used later because the ReadNum method just read it again.\nWe got a race-condition double-fetch issue here.\nExploit So we pass a large structure to pass the size checks and then create a new thread that repeatedly changes the index argument field between a valid index and an out-of-bounds index until we have our target index in the output structure.\nAfter tries, in the best-case scenario, we will have the correct value at the correct time.\nThe issue is shared between the readNum and writeNum method.\nBy printing the value at various out-of-bound index, we found a persistent(not across reboot) kernel address at the index -30.\nRead that and we will defeat the kASLR.\n(to be continued)\nYet another bug The fillArray method seems interesting as it may be exploited to smash the kernel stack for ROP.\nIt copies our passed array to a local static-size array and then manually copies 10 int64_t value to the field array.\nThe size will be copied is stored in an initialized field of the UserClient class.\nExploit (continued) With our relative address out-of-bound write, we can corrupt that value and make it copies as much as we want and smash the kernel stack.\nPlease bear in mind that the arguments struct reference is put on the stack and you must not overwrite it with an invalid address as it\u0026rsquo;s later used to write the result of the write.\nI was too lazy at that time so I decided to run the exploit in a kernel version which I\u0026rsquo;ve already made a privilege escalation ROP chain.\nThe kernel I used was the one of build macOS 10.14.2 (18C54) but everything should be basically the same.\nTo be honest, I have to read a little spoiler before I finished the first exploit.\nThe attached exploit is the one I have cleaned up after reading the source and understanding the exploit completely\nThe flag for the challenge is\n OOO{woah i didnt know about kernel races!}\n Shoutout   Jeff Crowell - the challenge author for creating such an awesome challenge and sending me the source and the distribution after a year after the CTF took place.\n  Ole Henry Halvorsen and Douglas Clarke - the authors of the book OS X and iOS Kernel Programming\n  ","description":"","id":5,"section":"post","tags":["DEFCON-CTF","CTF","pwn","xnu","IOKit","race-condition","double-fetch"],"title":"IPwnKit DEFCON CTF 26 QR","uri":"https://trungnguyen1909.github.io/blog/post/DEFCON26-Qual/iPwnKit/"},{"content":"House-of-loop Hi everyone, this is the writeup for the challenge House-of-loop in the AceBear Security Contest 2019\nYou may want to checkout the exploit code\nDescription We are given a stripped ELF x64 binary which can be interacted with, our task is to get remote code execution(RCE).\nThe binary presents us 3 options: Create, View and Delete a note.\nWhen creating a note, we have 3 fields: Title, Private, and Description.\nWe have the limits on Title, Private field length but with Description, we can use as much as we specified.\nWhen viewing a note, we can view the Title and Description fields but not Private.\nWhen deleting a note, we specify the Title of the note which we want to delete and then it will be removed from the view.\nI spent 1h30 to reverse and understand the binary and decompile the binary.\nThe fully decompiled program is at here.\nEDIT: Almost forgot, I used syms2elf plugin to get the function symbols into the executable (a.k.a de-strip) :)\nTechnical Details When creating a note, it malloc(144) for the note, note‚Äôs title is at offset 96 of the struct.\nThe title is null-terminated at offset 25 although we can write 32bytes.\nPrivate data is written to the beginning(offset 0).\nLastly, It asks us for the description size, malloc enough data, zero it out, finally read in an exact number of bytes.\nThe address of the description is then saved in its field.\nThen the program goes on a check if it was the first note created or loop through the singly-linked list until the next_note field is null, it puts the address of the newly-created note there.\nWhen deleting a note, it loops through the linked list to find the note with the matched title, unlink it from the singly-linked-list then free its data and itself.\nBugs While reversing the binary, I found out that the next_note field is not initialized at the time of creating and clear it at the time of deletion.\nSo it left a dangling pointer there and also picked up the dangling pointer which is left there earlier.\nSo that opens us a use-after-free vulnerability.\nMeanwhile, it creates a problem that if we are careless, we can put the program in an endless loop by having the next_note field points (directly/indirectly) to itself.\nAfter hours of trying the program, I also found a critical logic bug.\nThe chunk that is malloc-ed to store the Description is memset by the size we entered but not the actual chunk size.\nWhich means, if we create a 0-sized description, it will then malloc(0), which gives 16 bytes, then memset(chunk,0,0) (which is nonsense).\nSo, we got an information disclosure of anything that was there before :)\nExploit Checksec [+] checksec for '/root/house_of_loop/house_of_loop' Canary: Yes NX: Yes PIE: Yes Fortify: No RelRO: Full Information Disclosure To leak a pointer, we can use the 0-sized description to leak the FD, BK of that chunk.\nFYI, FD, BK pointers are used when a chunk is freed to points to the next free one.\nThat‚Äôs cool, we can easily leak the heap address.\nBut what about libc? Where can I find it?\nSince glibc 2.26 with the introduction of tcache, we have a libc-info-leak\nA chunk inside the unsorted bin will have a pointer to an libc address in the fd if that is the last chunk and in bk, if it was the first one.\nReference\nIn my exploit, at line 67, I allocate a description that is big enough to go to the unsorted-bin, then I freed it, try to re-allocate that chunk with a 0-sized description. Because it was the last chunk, there will be a pointer :)\nThere was a reason why I also free the last chunk allocated. If we don‚Äôt do so, the last chunk we allocated will point to that chunk, but the dangling pointer there will throw us a ‚àû loop\nIn other words, let consider the heap currently be allocated like this\n| A | B | C | D | v ^ v ^ v ^ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò A is that big chunk, D is the last one we allocated.\nThe line represents the linked list pointer to the next note. They don‚Äôt go away upon deleting.\nWhen you free A, then reallocate it, it will stay at the same position but with the pointer.\nD will the points to A(the next one allocated) then A-\u0026gt;B-\u0026gt;C-\u0026gt;D =\u0026gt; ‚àû loop\nBy also free D after A, these things happen:\n  D\u0026rsquo;s next_note(which is 0 because it is the last one) will be saved to C, which marks C as the last note.\n  Because of malloc‚Äôs natural of a first-fit algorithm, the reallocated one will have the struct lied on D‚Äôs location and the description at A‚Äôs description.\n  Because D has next_note field equal to 0 so it will be the last note(the previous one is C)\n  The address will be at the description of the last allocated note.\n  And that‚Äôs how you leak the libc address.\n  You can see the execution trace at here\nFrom UAF to ACE So the only field that was not initialized was next_note, so how can we control it?\nTo leave there an arbitrary pointer, we need to create another note that has the description size is the same size as the note structure.\nThen we can attempt to re-allocate the description(which we have full control) as the note structure.\nTo re-allocate it, firstly, we will need to allocate a note that has the description‚Äôs size strictly greater than the note structure.\nBy doing that, we can make sure that our crafted struct is not being used as the description of the other note.\nThen, the next note we allocate will lie on our crafted struct\nIllustration\nBefore:\n| A | data of A(144)| B | data of B(144)| | crafted | After:\n| C | D | B | data of B(144)| Data of C(144+) | But‚Ä¶, what will we put there‚Ä¶???\nOkay, we will set up an arbitrary-write primitive.\nThe GOT is Fully Protected, which mean it is read-only\nNow, we are introducing to you the MALLOC HOOKS\nThe malloc hooks are available for debugging heap purpose, and it‚Äôs executed before any malloc operations\nIf the data at variable __free_hook or __malloc_hook is not NULL, it will be executed.\nSo, if we write the address we want there, and we will have ACE (Arbitrary Code Execution)\nIdeally, you may want to write an address of a one_gadget there for the sake of simplicity.\nBut how?\nLet‚Äôs check out this piece of code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  int del_note(){ //tbf_note: to be freed note  //prev_note: the previous note of the one we want to free  //s1: the title of the note we want to free  ... for ( tbf_note = first_note; tbf_note \u0026amp;\u0026amp; strncmp(\u0026amp;s1, tbf_note-\u0026gt;title, 0x20uLL); tbf_note = tbf_note-\u0026gt;next_note ) prev_note = tbf_note; if ( tbf_note ) { if ( prev_note ) prev_note-\u0026gt;next_note = tbf_note-\u0026gt;next_note; else first_note = tbf_note-\u0026gt;next_note; free(tbf_note-\u0026gt;data); free(tbf_note); ... }   As you can see, the program finds the note that we want to delete then does this piece of code:\nprev_note-\u0026gt;next_note = tbf_note-\u0026gt;next_note;\nIt takes the address of the note that goes after the note will want to free, and then make it be the next_note of the note that comes before the one we want to free.\nIllustration!!!\nBefore:\n| A | B | C | v ^ v ^ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò After:\n| A | freed | C | v ^ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Basically, what it does it unlink that note from the linked list\n Hey, have you learned the old-school dlmalloc unlink exploit yet?\n The idea is simple,\n  Let\u0026rsquo;s make the A note lie on somewhere near __free_hook\n Use the _use-after-freevuln to make__free_hookaddress as thenext_note`    Create a new note from A(Let\u0026rsquo;s called it B)\n  Then we unlink B off the linked_list\n  Anything at B-\u0026gt;next_note will be put in A-\u0026gt;next_note !!!! (Isn\u0026rsquo;t that Arbitrary Write?)\n  =\u0026gt; Let\u0026rsquo;s make __free_hook is also the next_note field of A :)\n Isn\u0026rsquo;t that the famous dlmalloc unlink exploit? ;)\n Friendly Reminder: Don\u0026rsquo;t forget to fill up the heap holes you created by any stage of this exploit :)\nUAF-\u0026gt;AW-\u0026gt;ACE trace\nShoutout to   chung96vn for creating this challenge(or the opportunity for me to learn heap exploit :))\n  This writeup\n  @ducphanduyagentP for letting me know about syms2elf\n  You, Yes. You, for staying till this end of this writeup :)\n  ","description":"","id":6,"section":"post","tags":["AceBear","CTF","pwn","heap"],"title":"AceBear Security Contest House-of-loop","uri":"https://trungnguyen1909.github.io/blog/post/AceBear2019/house_of_loop/"},{"content":"Baby Sandbox This is a challenge of TetCTF, which is hosted from Jan 1st to Jan 7th by MeePwn Team of Vietnam\nYou may want to checkout the exploit code\nChallenge description We are given 2 binary, one is sandbox and the other one is program.\nsandbox, judging by its name, is a implementation of sandbox, executing the program passed in argv[1] in an sandbox environment.\nprogram is executed by sandbox, which is a simple static stripped executable which simply reads your input and then output it.\nReversing sandbox forks and execve a child process that passed in argv[1], then use ptrace to monitor it\nAt every syscall, it checks if the syscall is not blacklist and not violates custom rules and then choosing whether to stop it or continue.\nSome syscalls are blocked are fork, execve, open (filename containing flag), \u0026hellip;\nprogram is a statically-linked stripped binary, reads input, writes it out, do a mystery function 3 times then exits.\nBugs sandbox blacklists syscall, but it only blacklists x86_64 system call numbers.\nThe difference between x86 and x86_64 syscall table allows us to using forbidden syscalls\nprogram has a buffer-overflow, which allowing arbitrary code execution\nExploit To escape the sandbox, we can fork it using 32bit syscall number. The newly spawned process will be off-the-radar.\nThe file poc.s is a sandbox-escape proof-of-concept, which will escape itself and spawn a shell\nprogram is a statically-linked, which allows us to have a good surface for ROPing\nI decided to make the stack executable to allow us to injecting the shellcode.\nWhile searching for solutions such as mmap or mprotect, I suddenly remember to _dl_make_stack_executable,\nwhich always available in statically-linked binary.\nThe way I found it was while searching for mov eax, 9;syscall for mprotect syscall,\nI suddenly realised that the function that it was found in, is definitely the libc wrapper for mprotect\nSearching reference to this function, I found 3 ones that has reference to mprotect.\nBy comparing those function reference offset to mprotect to the one in the others libc,\nWe can find the _dl_make_stack_executable function. Its reference to mprotect is about 0x26 to 0x27 bytes from the function beginning.\nWith some reversing in that function, we can use it to make the stack executable again.\nThis technique first appeared in the CTF was in the BKPCTF Simple Calc Challenge.\nAfter that, we can push rsp;ret to jump to our following shellcode.\nWhile doing this, you will realise that the function that is called last in main was close(fd).\nIt was used to close all pipe before leaving.\nAlso, please bear in mind that program will only read 256(0x100) bytes so make sure everything fits in.\nMy exploit use 255/256 bytes, which is nice(although it is a bit infuriating by leaving one-byte unused)\nThe first shellcode is responsible for opening a reverse shell, reading the next shellcode to a fixed executable mmap then returning to this.\nThe second shellcode is responsible for escaping sandbox and then gives us a shell.\n","description":"","id":7,"section":"post","tags":["TetCTF","CTF","pwn","sandbox","ROP","NX"],"title":"TetCTF babySandbox","uri":"https://trungnguyen1909.github.io/blog/post/tetctf/babysandbox/"},{"content":"Kernel Debugging Instruction Setup I used VirtualBox for Kernel Debugging, VMWare shoud be able to do the same thing.\nEnter Machine Settings -\u0026gt; Ports -\u0026gt; Serial -\u0026gt; Enable Serial Port\nPort Number: Any :)))\nPort mode: Host Pipe\nConnect to existing : unchecked\nPath/Address: /tmp/vbox (placeholder purpose :))\nBoot Linux normally, run as root\n$ echo ttyS0,9600 \u0026gt; /sys/module/kgdboc/parameters/kgdboc\nif Port Number is COM1, use ttyS0; if it is COM2, use ttyS1\u0026hellip; etc\nReturn to the host machine, run\n$ socat -d -d /tmp/vbox pty \u0026amp;\nSocat will run in the background, output the debugger serial port tty.\nFetch /boot/vmlinuz , extract with extract-vmlinux (available in the Linux Source Tree)\ngdb vmlinuz (gdb) target remote /dev/ttyXXX //The one that socat outputed Enjoy!\nNotes  You can only attach when the kernel panic, the KDB fired up  P/s: Maybe we can attach from start with boot flag kgdboc ttyS0,9600 kgdbwait?\nBut it is irrelevant for the purpose of this document so I won\u0026rsquo;t discuss about it here\nReference Somewhere in the internet :\u0026lt; Sorry\n","description":"","id":8,"section":"post","tags":["debug","kernel","linux"],"title":"Linux Kernel Debugging in VM","uri":"https://trungnguyen1909.github.io/blog/post/misc/KDB/KDB/"},{"content":"KSMASH - Kernel Stack Smashing Background This is a Linux Kernel Module(LKM) exploitation challenge by nyaacate@gmail.com host in Round 3 MatesCTF 2018-2019\nI solved this challenge overtime :\u0026lt;\nBut It seems that no team solved this so I still sent the exploit to the challenge author for testing and also wrote this writeup.\nYou may want to checkout the exploit code\nChallenge Description A kernel module is running, escape from non-root user to r00t to read /root/flag\nReversing Kernel module is named kmod, You can find the module using this command\n$ modinfo kmod filename: /lib/modules/4.18.0-15-generic/kernel/drivers/char/kmod.ko author: nyaacate license: Unlicense srcversion: 764EF51CE35A221A02D9CA0 depends: retpoline: Y name: kmod vermagic: 4.18.0-15-generic SMP mod_unload Fire up IDA64, load kmod.ko, It shown that\n  Kernel module can be communicated through the pseudo-file /proc/havoc\n  Read from it, the kernel module will read up the kernel stack memory for us with the function careless_read\n  Write to it, the kernel module will copy our data to the kernel stack memory for us with the function careless_write :)\n  Both of them perform copy_from_user/copy_to_user for all of the input to an one-byte sized stack variable\n  This is a Simple Buffer-Overflow\u0026hellip; but at Kernel level.\n  Protection :   kASLR (kernel level Address Space Layout Randomization)\n  SMEP (Supervisor Mode Execution Protection) : Preventing Ring 0 from fetching instruction from userspace memory\n  Kernel Stack Cookies (Canary)\n  Exploit Vector : From kernel, we need to call commit_creds(prepare_kernel_cred(0)) to elevate privilege to r00t then return safely to userspace.\n  At first, we read kernel stack memory from /proc/havoc to have some informations\n  All important ones are located from offset 1. Below this the data layout from offset 1.\n  \t--------------------------- | Stack Canary | --------------------------- | Saved RBX | --------------------------- | Saved RBP | --------------------------- | Saved RIP | ---------------------------   Based on this, we can easily defeat Stack Canary and kASLR\n  Kernel ASLR can be defeated by calculating saved RIP offset.\n  Last job is to elevate to r00t and then safely return back.\n  Although there aren\u0026rsquo;t usable gadget mov rdi, rax to manipulate prepare_kernel_cred result for commit_creds,\nBut RAX is the same with RDI after the call for some reason so we can skip that gadget.\n  Finally do SWAPGS then IRETQ (interrupt return) to return to our exploit program from Kernel.\n  IRETQ is responsible for recovering RIP, CS, RFLAGS, RSP, SS, Specifically, it will pop from stack like this figure.\n |--------------------------| | Low mem addr | ^ |--------------------------| | | RIP | | |--------------------------| | | CS | | |--------------------------| | | EFLAGS | | |--------------------------| | | RSP | | |--------------------------| | | SS | | |--------------------------| | | High mem addr | | |--------------------------| |    Notes \u0026amp; Issue  When IRETQ back, I got SIGSEGV on every single instruction RIP is pointed to :\u0026lt;  So I used a cool dirty trick to handle is to handle signal SIGSEGV with a function that calls system(\u0026quot;/bin/sh\u0026quot;) :))\n  ret2usr can\u0026rsquo;t be used since Linux 4.15, all userspace memory in kernel will be mapped as non-executable\n  SIGSEGV when iretq is caused by KPTI(Kernel Page Table Isolation) (a.k.a KAISER) which appeared since 4.15 as a patch for Meltdown\n(Can be resolved by patching CR3?)\n  Everything else should be found from exploit.c file\n  Gotchas :)  Source is available within the distribution in /home/nyan  Reference Distribution\nROP your way to Kernel part 1\nROP your way to Kernel part 2\nPractical SMEP bypass techniques on Linux\nAll 3 from Vitaly Nikolenko :O\nChanges in Linux Kernel\n","description":"","id":9,"section":"post","tags":["matesCTF","CTF","pwn","kernel","linux"],"title":"matesCTF KSMASH","uri":"https://trungnguyen1909.github.io/blog/post/matesctf/KSMASH/"},{"content":"Pillow Background This is the writeup for the challenge Pillow, created by Samuel Gro√ü(@saelo) of Project Zero, of 35C3 CTF annually organized by @EatSleepPwnRpt happening at the end of year 2018.\nI didn\u0026rsquo;t solve this challenge during the CTF, when revisiting this challenge after checkout @LinusHenze repo, I have a big learning oppuntunity to checkout XNU exploitation, which was completely new to me.\nYou may want to checkout the exploit code\nBasic stuff Feel free to skip this part if you have already had a basic knowledge in Mach.\nMach Mach 3.0 was originally conceived as a simple, extensible, communications microkernel. It is capable of running as a stand-alone kernel, with other traditional operating-system services such as I/O, file systems, and networking stacks running as user-mode servers.\nMach is used to send messages or do remote procedure calls (RPC) between separate tasks. This modular structure results in a more robust and extensible system than a monolithic kernel would allow, without the performance penalty of a pure microkernel.\nMore information\nMach Port In Mach kernel, port is a very important concept, especially at its reference counting.\nPort is a one-way transmission channel. The corresponding object in kernel is the ipc_port.\nThere can only be one receiver but there can be multiple senders.\nTo be able to send a message through a port, you must have a send right to it.\nWhen sending and receiving mach messages from userspace there are two important kernel objects, which are the foundation of Mach Port: ipc_entry and\nipc_object.\n ipc_entry are the per-process handles or names which a process uses to refer to a particular ipc_object.\n  ipc_object is the actual message queue (or kernel object) which the port refers to.\n  ipc_entry have a pointer to the ipc_object they are a handle for along with the ie_bits field which contains\nthe urefs and capacility bits for this name/handle (whether this is a send right, receive right etc.)\n  Each time a new right(send or receive) is received by a process, if it already had a name for that right the kernel will\nincrement the urefs count. Userspace can also arbitrarily control this reference count via mach_port_mod_refs\nand mach_port_deallocate. When the reference count hits 0 the entry is free\u0026rsquo;d and the name can be re-used to\nname another right.\n  -Ian Beer(@i41nbeer) of Google Project Zero-\n  Source\n Port has two different usage. The first is for inter-process-communication (IPC); the second is for representing a kernel object.\nFor this writeup, we will only focus on IPC usage.\nMIG  In Apple\u0026rsquo;s code, there is one called MIG, which is automatically generated according to the defs file. It usually does some inter-core object conversion (such as from port to kernel object) and object reference count management, and then call the real kernel functions. If the kernel developer is not familiar with the meaning of defs or MIG\u0026rsquo;s management of object reference counts, there is high possibility to manage the reference counts of the kernel objects improperly in the real kernel API of this MIG package, thus causing leaks of the reference counts or double free.\n  -Qixun Zhao(@S0rryMybad) of Qihoo 360 Vulcan Team-\n Challenge The distribution gives you 4 files, 2 Launch Daemons config and 2 executable act at daemon.\nshelld looks promising, there is a function shell_exec with call an arbitrary command after do some verification with capsd\nBug shelld\n1 2 3 4 5 6 7 8 9 10 11 12 13  kern_return_t register_completion_listener(mach_port_t server, const char* session_name, mach_port_t listener, audit_token_t client) { CFMutableDictionaryRef session = lookup_session(session_name, client); if (!session) { mach_port_deallocate(mach_task_self(), listener); return KERN_FAILURE; } CFNumberRef value = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, \u0026amp;listener); CFDictionaryAddValue(session, CFSTR(\u0026#34;listener\u0026#34;), value); CFRelease(value); return KERN_SUCCESS; }   This function is called by the MIG server.\nThe problem is that it does not respect the MIG schematics\n If a MIG method returns KERN_SUCCESS it means that the method took ownership of all the arguments passed to it.\nIf a MIG method returns an error code, then it took ownership of none of the arguments passed to it.\nSource\n What does it mean that if the function return KERN_SUCCESS, it is responsible to manage all the resources passed in.\nOtherwise, MIG will responsible for freeing all of it.\nBy mach_port_deallocate, the listener port will be double-freed (by the function and MIG) and the uref(userspace-reference count) will be decreased.\nWhen the uref reaches zero, it means that all connection to that port is deallocated, the port will be freed and be reused later\n When the receive right/port have already have a reference(name) in the task, the uref will be increased by one\nand decreased by one when it is deallocated\n Exploitation If we pass in the capsd port to the listener and an invalid session, the port that shelld communicates with capsd will be freed and we can attach our port to it by using register_completion_handler.\n=\u0026gt; IPC Man-in-the-middle\nOne more thing, even if we have passed capsd check, we still have the macOS Sandbox enforced to a session-name\nTo bypass this, we create a session with a super long name, then the sandbox will refused to enforce due to long path.\n=\u0026gt; Arbitrary Code Execution outside the sandbox.\nOther technical/implementation is noted in the exploit.c, please check it out.\nReference Official Source Code\nReference\n","description":"","id":10,"section":"post","tags":["35C3-CTF","CTF","pwn","xnu","mach","mig"],"title":"35C3 CTF Pillow","uri":"https://trungnguyen1909.github.io/blog/post/35c3/pillow/"},{"content":"By cating and grepping the file, we know that there was a file named /home/memes/flag.c\nIt\u0026rsquo;s probably a program, so I searched for ./flag\nJust printing the line doesn\u0026rsquo;t seem to work so I tried\n cat memorydump | grep -A 10 -B 10 ./flag I found an interesting base64-encoded string that is repeated multiple times.\nDecode it, the flag is yours.\nAlso, later I realised that a great pattern to grep for challs like this are the base64-encoded of the beginning part of the flag format, which is constant.\nSuch as\n cat memorydump | grep UklUU0VDe which works really well for this challs.\n","description":"","id":11,"section":"post","tags":["RITSEC","CTF","forensics"],"title":"RITSEC18 Bucket-o-cash","uri":"https://trungnguyen1909.github.io/blog/post/RITSEC-2018/Bucket-o-cash/"},{"content":"It\u0026rsquo;s clearly a python compiled program since there is a libpython and also, when using decompiler, there was a function name PyDontWriteByteCode\nusing \u0026lsquo;pyi-archive-viewer\u0026rsquo; we can extract the main function.\nAppend headers to the file\n \u0026quot;\\x03\\xf3\\x0d\\x0a\\xf1\\x32\\x75\\x5a\u0026quot; using uncompyle, we can get the main function.\nChange the key a little bit ¬±k*360 and we will get the flag.\n","description":"","id":12,"section":"post","tags":["RITSEC","CTF","reversing","Python"],"title":"RITSEC18 Freeze","uri":"https://trungnguyen1909.github.io/blog/post/RITSEC-2018/Freeze/"},{"content":"The binary loads the flag.txt to the memory and asks us to provide input.\nInteresting things is that it loads to the same memory segment with the input.\nDebugging locally, I found it at the offset 752 from the first input bytes.\nRunning it multiple times on the server and at sometimes, the null bytes will be all-cleared and puts will print it all.\n","description":"","id":13,"section":"post","tags":["RITSEC","CTF","pwn","golang"],"title":"RITSEC18 Gimme sum fud","uri":"https://trungnguyen1909.github.io/blog/post/RITSEC-2018/Gimme-sum-fud/"},{"content":"wget -r fun.ritsec.club:8007\nYou may find the file Fl4gggg1337.html is referenced or has already been download. The flag wasn\u0026rsquo;t there, but it has link to Stars.html.\nFetch that file, the base64 encoded string is the flag for this challenge.\n","description":"","id":14,"section":"post","tags":["RITSEC","CTF","web"],"title":"RITSEC18 The tangled web","uri":"https://trungnguyen1909.github.io/blog/post/RITSEC-2018/The-tangled-web/"},{"content":"By judging the program\u0026rsquo;s interface, we know that it was a heap challenge.\nSpent quite a lot of time reversing it, I figured it out that it malloc a few bytes for the person struct on the heap, then the name will be malloc with the size entered and that address will be put in the person struct.\nThe person struct also has a function pointer which is set to the printPerson function.\nThe edit feature doesn\u0026rsquo;t check the bound, it just read the number of bytes that we specified.\nSo we can use the edit name function to overwrite other person data, which included the function pointer and the name pointer.\nSince the person struct is small, I decided to first create a person with small name and then edit it to overflow the second one to make the heap looks like this\nStruct person 1 | Person 1 Name | Struct person 2 | Person 2 Name |\nI did some reversing and testing and find out what to overwrite.\nFirst I overwrite the name pointer to the got table to leak the libc.\nThen I overwrite the function pointer to system and put the \u0026ldquo;;/bin/sh\\x00\u0026rdquo; string at the address.\nMind the semi-colon, It allows you to skip the prepended bytes.\nWell, I figured out how the addresses are being used just by testing and inspecting the heap many times.\nAnyhow, it works.\nWell, the problem is that the offset isn\u0026rsquo;t always the same.\nBut with some luck, I managed to exploit the networked binary once after many times running it again and get the flag. :)\nBut then after, I couldn\u0026rsquo;t exploit it again, ever.\nAfter the ctf ended, I investigated and find 2 others offset which makes the chance of success increased a lot.\nThe chance of success is about 80%, but that\u0026rsquo;s enough for the flag.\n","description":"","id":15,"section":"post","tags":["RITSEC","CTF","pwn","heap","golang"],"title":"RITSEC18 Yet another HR Management Framework","uri":"https://trungnguyen1909.github.io/blog/post/RITSEC-2018/Yet-another-HR-Management-Framework/"},{"content":"babyOVERFLOW Exploit\nT√™n file b√†i n√†y g·ª£i √Ω r·∫•t nhi·ªÅu.\n\u0026ldquo;baby\u0026rdquo; th∆∞·ªùng ƒë∆∞·ª£c d√πng trong CTF ch·ªâ nh·ªØng b√†i ƒë∆°n gi·∫£n d√†nh cho ng∆∞·ªùi m·ªõi\n\u0026ldquo;OVERFLOW\u0026rdquo; ·ªü ƒë√¢y th√¨ ch·ªâ ƒë·∫øn stack buffer overflow.\nCh·∫°y n√≥, nh·∫≠p v√†o th√¨ n√≥ in ra l·∫°i ƒë√∫ng nh∆∞ th·∫ø.\nTa c√≥ th·ªÉ th·ª≠ nh·∫≠p v√†o \u0026ldquo;%x\u0026rdquo; ƒë·ªÉ xem c√≥ format string kh√¥ng th√¨ k·∫øt qu·∫£ l√† ch∆∞∆°ng tr√¨nh ch·∫°y b√¨nh th∆∞·ªùng\nTh·ª≠ v·ªõi 1 input th·∫≠t d√†i th√¨ th·∫•y kh√¥ng c√≥ l·ªói g√¨ x·∫£y ra.\nCtrl+D ƒë·ªÉ g·ª≠i EOF th√¨ c≈©ng kh√¥ng tho√°t ch∆∞∆°ng tr√¨nh. M√¨nh th·ª≠ vi·∫øt \\x00 b·∫±ng printf th√¨ ch∆∞∆°ng tr√¨nh d·ª´ng.\nB·∫±ng Code Python inline, m√¨nh th·ª≠ in ra 100 c√°i \\x00 th√¨ th·∫•y\n*** stack smashing detected ***: \u0026lt;unknown\u0026gt; terminated Aborted √Ä t·ª©c l√† ƒë√¢y ch√≠nh x√°c l√† 1 b√†i BOF c∆° b·∫£n c√≥ stack canary\nGi·ªù l√† l√∫c ƒë·ªÉ checksec binary:\n Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Ch√∫ng ta c√≥ 1 binary 64bit, no-PIE, NX(W^X) c√≥ canary.\nLeak stack canary M√¨nh d√πng pattern \u0026amp; gdb break t·∫°i ƒëo·∫°n ki·ªÉm tra cookies th√¨ t√¨m ra ƒë∆∞·ª£c cookies ·ªü offset 71(c√°ch ch·ªØ c√°i ƒë·∫ßu ti√™n l√† 71 k√≠ t·ª±)\nStack cookies lu√¥n ƒë∆∞·ª£c ghi b·∫Øt ƒë·∫ßu b·∫±ng null bytes \\x00 (little-endian) ƒë·ªÉ tr√°nh puts ho·∫∑c printf in ra.\nOK, v√¨ ta bi·∫øt n√≥ lu√¥n lu√¥n nh∆∞ v·∫≠y n√™n ta ghi ƒë√® l√™n n√≥ ƒë·ªÉ puts c√≥ th·ªÉ leak ƒë∆∞·ª£c canary ra.\nV√¨ v·∫≠y sau ƒë√≥, puts s·∫Ω in ra gi√° tr·ªã canary ·ªü cu·ªëi.\nNh∆∞ v·∫≠y l√† ta c√≥ th·ªÉ leak ƒë∆∞·ª£c canary 1 c√°ch d·ªÖ d√†ng.\nPayload:\n72 junk bytes.\nExploit Stack:\n Stack Cookies------------| -------------------------| Saved RBP----------------| -------------------------| Function return address--| -------------------------| Trong khi reverse th√¨ c√≥ th·ªÉ nh·∫≠n th·∫•y r·∫±ng v√≤ng l·∫∑p ƒë·ªçc-vi·∫øt s·∫Ω k·∫øt th√∫c khi k√≠ t·ª± ƒë·∫ßu c·ªßa input = \\x00\nTa c√≥ s·∫µn h√†m canyourunme ƒë·ªÉ ch·∫°y shell\nPayload:\n71 Bytes + Canary + 8 bytes + v·ªã tr√≠ c·ªßa canyourunme + 4\nKh√¥ng hi·ªÉu t·∫°i sao m√† n·∫øu kh√¥ng + 4 th√¨ s·∫Ω ƒÉn segfault ·ªü server. M√¨nh t·ªën c·∫£ ti·∫øng ƒë·ªìng h·ªì ƒë·ªÉ c√≥ th·ªÉ qua ƒë∆∞·ª£c ƒëo·∫°n n√†y\nC√≥ l·∫Ω l√† do push rbp;mov rbp,rsp c√≥ g√¨ ƒë√≥ kh√¥ng ƒë√∫ng.\nAnyway l√† sau ƒë√≥ cat flag l√† ta s·∫Ω c√≥ flag\n ","description":"","id":16,"section":"post","tags":["matesCTF","CTF","pwn","stack-buffer-overflow"],"title":"matesCTF babyOVERFLOW","uri":"https://trungnguyen1909.github.io/blog/post/matesctf/babyOVERFLOW/"}]